CREATE TYPE if not exists post_status_enum AS ENUM ('public', 'private', 'follower');
DROP TABLE IF EXISTS posts CASCADE;

CREATE TABLE posts (
    seq          BIGINT GENERATED ALWAYS AS IDENTITY Unique,          -- 고유 PK
    id          BIGINT GENERATED BY DEFAULT AS IDENTITY primary key,          -- 고유 PK
    group_id        BIGINT,                         -- 루트 글 ID (root면 자기 자신)
    level           INT DEFAULT 0,                  -- 깊이 (root = 0)
    parent_id       BIGINT NULL,                    -- 부모 글 ID
    FOREIGN KEY (parent_id) REFERENCES posts(id) on delete cascade,
    -- --
    priority        INT NOT NULL DEFAULT 100,
    -- reply_count     INT DEFAULT 0,                  -- 자식 글 수
    slug            VARCHAR(255) NOT NULL,
    title           VARCHAR(255) NOT NULL,
    content         TEXT,
    category_id     BIGINT NULL,
    user_id         BIGINT NOT NULL,
    description     TEXT DEFAULT NULL,
    status          post_status_enum NOT NULL DEFAULT 'public',    
    -- --
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at      TIMESTAMP DEFAULT NULL
);

-- group_id 기준 조회 최적화
CREATE INDEX idx_posts_group_id ON posts(group_id);


WITH RECURSIVE post_tree AS (
    -- 1️⃣ 루트 글 선택
    SELECT
        id,
        group_id,
        level,
        parent_id,
        priority,
        reply_count,
        title,
        content,
        created_at,
        updated_at,
        deleted_at,
        LPAD(id::text, 10, '0') AS path
    FROM posts
    WHERE parent_id IS NULL

    UNION ALL

    -- 2️⃣ 댓글 선택
    SELECT
        p.id,
        p.group_id,
        p.level,
        p.parent_id,
        p.priority,
        -- p.reply_count,
        p.title,
        p.content,
        p.created_at,
        p.updated_at,
        p.deleted_at,
        pt.path || '.' || LPAD(p.id::text, 10, '0') AS path
    FROM posts p
    JOIN post_tree pt ON p.parent_id = pt.id
)
SELECT
    ROW_NUMBER() OVER (ORDER BY path, priority ASC) AS row_num,
    id,
    group_id,
    level,
    parent_id,
    priority,
    -- reply_count,
    title,
    content,
    created_at,
    updated_at,
    deleted_at
FROM post_tree
ORDER BY path, priority ASC;


-- select posts with categories
WITH RECURSIVE category_tree AS (
  -- 루트 카테고리
  SELECT 
    id,
    parent_id,
    group_id,
    level,
    priority,
    name,
    LPAD(id::text, 6, '0') AS path
  FROM categories
  WHERE parent_id IS NULL
    AND deleted_at IS NULL

  UNION ALL

  -- 자식 카테고리
  SELECT 
    c.id,
    c.parent_id,
    c.group_id,
    c.level,
    c.priority,
    c.name,
    ct.path || '.' || LPAD(c.id::text, 6, '0') AS path
  FROM categories c
  JOIN category_tree ct ON c.parent_id = ct.id
  WHERE c.deleted_at IS NULL
),

combined_tree AS (
  -- 카테고리 노드
  SELECT 
    'CATEGORY' AS node_type,
    ct.id,
    ct.parent_id,
    ct.group_id,
    ct.level,
    ct.priority,
    ct.name AS title,
    NULL::BIGINT AS post_id,
    NULL AS slug,
    NULL AS content,
    NULL AS description,
    NULL::TIMESTAMP AS created_at,
    NULL::TIMESTAMP AS updated_at,
    ct.path
  FROM category_tree ct

  UNION ALL

  -- 게시글 노드 (카테고리의 group_id 상속)
  SELECT 
    'POST' AS node_type,
    p.id,
    p.category_id AS parent_id,
    ct.group_id AS group_id,          -- 카테고리의 group_id 상속
    ct.level + 1 AS level,
    p.priority,
    p.title,
    p.id AS post_id,
    p.slug,
    p.content,
    p.description,
    p.created_at,
    p.updated_at,
    ct.path || '.' || LPAD(p.id::text, 6, '0') AS path
  FROM posts p
  JOIN category_tree ct ON p.category_id = ct.id
  WHERE p.deleted_at IS NULL
)

SELECT 
  node_type,
  id,
  parent_id,
  group_id,
  level,
  priority,
  title,
  post_id,
  slug,
  content,
  description,
  created_at,
  updated_at,
  ROW_NUMBER() OVER (ORDER BY path) AS sort_key
FROM combined_tree
ORDER BY path;